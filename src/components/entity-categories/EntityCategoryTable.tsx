//Generated by WriteToModeltable_tsx - ModelTable.tsx for Table 9/18
"use client";
import React, { useEffect } from "react";
import {
  EntityCategoryFormikInitialValues,
  EntityCategoryModel,
  EntityCategorySearchParams,
} from "@/interfaces/EntityCategoryInterfaces";
import { useQueryClient } from "@tanstack/react-query";
import { UpdateModelsData, useModelsQuery, useUpdateModelsMutation } from "@/hooks/useModelQuery";
import { EntityCategoryConfig } from "@/utils/config/EntityCategoryConfig";
import { BasicModel, GetModelsResponse } from "@/interfaces/GeneralInterfaces";
import { useModelPageParams } from "@/hooks/useModelPageParams";
import { getCurrentData } from "@/lib/getCurrentData";
import { getRefetchQueryFunction } from "@/lib/refetchQuery";
import { useTableProps } from "@/hooks/useTableProps";
import ModelDataTable from "@/components/ModelDataTable";
import { createRequiredModelLists } from "@/lib/createRequiredModelLists";
import { getInitialValues } from "@/lib/getInitialValues";
import { toast } from "@/hooks/use-toast";
import { Formik, FormikHelpers, FormikProps } from "formik";
import { ModelSchema } from "@/schema/ModelSchema";
import useGlobalDialog from "@/hooks/useGlobalDialog";
import EntityCategoryForm from "@/components/entity-categories/EntityCategoryForm";
import { Row } from "@tanstack/react-table";
import { findModelPrimaryKeyField } from "@/utils/utilities";
import EntityCategorySingleColumn from "@/components/entity-categories/EntityCategorySingleColumn";
import { useGenericMutation } from "@/hooks/useGenericMutation";
import { getGenericMutationEndpoint } from "@/lib/getGenericMutationEndpoint";
import { removeRequiredListFromLocalStorage } from "@/lib/removeRequiredListFromLocalStorage";


const EntityCategoryTable = <T,>({
  tableStates,
}: {
  tableStates: ReturnType<typeof useTableProps<T>>;
}) => {
  const modelConfig = EntityCategoryConfig;
  const primaryKeyFieldName = findModelPrimaryKeyField(modelConfig).fieldName;
  const { pluralizedModelName } = modelConfig;
  const pageParams = useModelPageParams<EntityCategorySearchParams>(modelConfig);
  const { params } = pageParams;
  const queryClient = useQueryClient();

  const [mounted, setMounted] = React.useState(false);

  //For Editable Tables
  const requiredList: Record<string, BasicModel[]> =
    createRequiredModelLists(modelConfig);

  //For Editable Tables
  const defaultFormValue = getInitialValues<T>(modelConfig, undefined, {
    childMode: true,
    requiredList,
  });

  //Store Variables
  const {
    page,
    setRecordCount,
    fetchCount,
    setFetchCount,
    currentData: previousData,
    setCurrentData,
    setIsUpdating,
  } = tableStates;

  const queryParams = params;

  const useEntityCategorySearchQuery = () =>
    useModelsQuery<T>(modelConfig, {
      ...queryParams,
      fetchCount: fetchCount.toString(),
    });

  const queryResponse = useEntityCategorySearchQuery();
  const { data, refetch, isFetching } = queryResponse;

  const currentPageData: GetModelsResponse<T> | null = data
    ? data.pages[page - (isFetching ? 2 : 1)]
    : null;
  const currentData = getCurrentData(
    currentPageData,
    previousData,
    modelConfig.isTable ? false : defaultFormValue
  );

  //Client functions
  const refetchQuery = getRefetchQueryFunction(
    modelConfig,
    params,
    refetch,
    queryClient
  );

  //Add any required mutations here
  /* 
  const addTaskTemplatesFromTemplateMutation = useGenericMutation({
    endPoint: getGenericMutationEndpoint(modelConfig, "Add From Templates"),
    onSuccess: (data) => refetchQuery(0),
  });

  const modelActions = {
    "Add Form Templates": addTaskTemplatesFromTemplateMutation,
  };
  */
  
  //This would produce the same shape as the modelActions above.
  const modelActions = undefined;

  const { mutate: updateRecords, mutateAsync: asyncUpdateRecords } =
    useUpdateModelsMutation(modelConfig);
  const rowActions = undefined;
  /* 
  Run WriteToGetmodelrowaction_tsx - getModelRowAction.tsx
  const rowActions = getEntityCategoryRowActions({
    currentData,
    setCurrentData,
    mutate: updateRecords,
  }); 
  */

  const columnsToBeOverriden = undefined;
  /* 
  Run WriteToGetmodelcolumnstobeoverriden_tsx - getModelColumnsToBeOverriden.tsx
  const columnsToBeOverriden = getTaskColumnsToBeOverriden<
    T,
    unknown
  >();
  */

  const handleSubmit = async (values: EntityCategoryFormikInitialValues, formik: FormikHelpers<EntityCategoryFormikInitialValues>) => {
    //The reference is the index of the row
    const rowsToBeSubmitted = (
      values[
        pluralizedModelName as keyof EntityCategoryFormikInitialValues
      ] as EntityCategoryFormikInitialValues["EntityCategories"]
    ).filter((item) => item.touched);

    if (rowsToBeSubmitted.length === 0) {
      toast({
        description: `No change detected.`,
      });
      return;
    }

    setIsUpdating(true);
    const payload = {
      [pluralizedModelName]: rowsToBeSubmitted,
    };

    //@ts-ignore
    asyncUpdateRecords(payload).then((data) => {
      removeRequiredListFromLocalStorage(modelConfig.modelPath);
      const { inserted, updated } =
        data as unknown as UpdateModelsData<EntityCategoryModel>;

      Object.keys(inserted).forEach((idx) => {
        const numIdx = idx as unknown as number;
        formik.setFieldValue(`${pluralizedModelName}[${idx}]`, {
          ...values[
            pluralizedModelName as keyof EntityCategoryFormikInitialValues
          ][numIdx],
          touched: false,
          [primaryKeyFieldName]:
            inserted[numIdx][primaryKeyFieldName as keyof EntityCategoryModel],
        });
      });

      setIsUpdating(false);
      toast({
        variant: "success",
        description: `${modelConfig.pluralizedVerboseModelName} successfully updated`,
      });
    });
    
  };
 
  const { openDialog, closeDialog } = useGlobalDialog();

  const openDialogHandler = (row?: Row<T>["original"]) => {
    openDialog({
      title: `${modelConfig.verboseModelName} Form`,
      message: (
        <div className="pt-8">
          <EntityCategoryForm
            data={(row ? row : null) as EntityCategoryModel | null}
            id={
              row
                ? (row[primaryKeyFieldName as keyof typeof row] as string)
                : "new"
            }
            modalFormProps={{
              onSuccess: () => {
                closeDialog();
                refetchQuery(page - 1);
              },
            }}
          />
        </div>
      ),
      formMode: true,
    });
  };

  const dialogFormProps = { openDialogHandler };

  /* const columnOrderToOverride: [string, number][] = [["isFinished", 2]]; */
  const columnOrderToOverride = undefined;
  
  useEffect(() => {
    setMounted(true);
    return () => {
      setMounted(false);
    };
  }, []);

  useEffect(() => {
    if (currentPageData?.count !== undefined) {
      setRecordCount(currentPageData?.count || 0);
    }
    setFetchCount(false);
    setCurrentData(currentData);
  }, [currentPageData?.count, data, page]);

  const commonProps = {
    modelConfig,
    tableStates,
    refetchQuery,
    queryResponse,
    pageParams,
    rowActions,
    modelActions,
    SingleColumnComponent: EntityCategorySingleColumn,
    requiredList,
    defaultFormValue,
    columnOrderToOverride,
  };

  return (
    mounted &&
    (modelConfig.isTable ? (
      <ModelDataTable
        {...commonProps}
        columnsToBeOverriden={columnsToBeOverriden}
        dialogFormProps={modelConfig.isModal ? dialogFormProps : undefined}
      />
    ) : (
      <Formik
        initialValues={
          {
            [pluralizedModelName]: currentData,
          } as unknown as EntityCategoryFormikInitialValues
        }
        enableReinitialize={true}
        onSubmit={handleSubmit}
        validationSchema={ModelSchema(modelConfig, true)}
        validateOnChange={false}
      >
        {(formik) => (
          <ModelDataTable
            {...commonProps}
            formik={formik as unknown as FormikProps<T>}
          />
        )}
      </Formik>
    ))
  );
};

export default EntityCategoryTable;
